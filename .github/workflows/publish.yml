name: Publish Python Package

on:
  workflow_run:
    workflows: ["Python Compatibility"]
    types:
      - completed
    branches:
      - main

jobs:
  check-conditions:
    runs-on: ubuntu-latest
    outputs:
      should_publish: ${{ steps.check-all-workflows.outputs.should_publish }}
    steps:
      - name: Check commit message
        id: check-commit
        if: contains(github.event.workflow_run.head_commit.message, 'ðŸ”–')
        run: echo "has_tag=true" >> $GITHUB_OUTPUT

      - name: Wait for other workflows
        id: workflow-check
        if: steps.check-commit.outputs.has_tag == 'true'
        timeout-minutes: 8
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha }}
          REPO: ${{ github.repository }}
        run: |
          max_attempts=15
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            # Get all workflow runs for this commit
            echo "Checking workflows for commit $COMMIT_SHA..."
            
            # Get the workflow runs in a more reliable way
            workflow_runs=$(gh api repos/$REPO/actions/runs \
              --paginate \
              --jq ".workflow_runs[] | select(.head_sha == \"$COMMIT_SHA\") | {id: .id, name: .name, status: .status}")

            echo "Current workflow runs:"
            echo "$workflow_runs" | jq .

            # Count running workflows
            running_workflows=$(echo "$workflow_runs" | jq -r 'select(.status != "completed") | .id' | wc -l)
            echo "Running workflows count: $running_workflows"

            if [ "$running_workflows" -eq "0" ]; then
              echo "All workflows completed"
              echo "all_complete=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "Attempt $attempt: Some workflows are still running. Waiting 30 seconds..."
              sleep 30
              attempt=$((attempt + 1))
            fi
          done

          echo "Timeout waiting for workflows to complete"
          echo "all_complete=false" >> $GITHUB_OUTPUT
          exit 1

      - name: Check required workflows
        id: check-all-workflows
        if: |
          steps.workflow-check.outputs.all_complete == 'true' &&
          steps.check-commit.outputs.has_tag == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          COMMIT_SHA: ${{ github.event.workflow_run.head_sha }}
          REPO: ${{ github.repository }}
        run: |
          # Get status of Tests workflow
          tests_status=$(gh api repos/$REPO/actions/workflows/tests.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"$COMMIT_SHA\") | .conclusion" | head -n 1)
          echo "Tests workflow status: $tests_status"

          # Get status of Python Compatibility workflow
          py_compat_status=$(gh api repos/$REPO/actions/workflows/python-versions.yml/runs \
            --jq ".workflow_runs[] | select(.head_sha == \"$COMMIT_SHA\") | .conclusion" | head -n 1)
          echo "Python Compatibility workflow status: $py_compat_status"

          # Check if both required workflows succeeded
          if [[ "$tests_status" == "success" && "$py_compat_status" == "success" ]]; then
            echo "Required workflows succeeded"
            echo "should_publish=true" >> $GITHUB_OUTPUT
          else
            echo "Required workflows did not succeed"
            echo "should_publish=false" >> $GITHUB_OUTPUT
          fi

  release:
    needs: check-conditions
    if: needs.check-conditions.outputs.should_publish == 'true'
    runs-on: ubuntu-latest
    environment:
      name: PyPI
      url: https://pypi.org/project/fastgear/

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python and Poetry
        uses: ./.github/actions/setup-python-poetry
        with:
          python-version: "3.13"

      - name: Install dependencies
        run: poetry install --no-root

      - name: Build package
        run: poetry build

      - name: Publish to PyPI
        env:
          PYPI_TOKEN: ${{ secrets.PYPI_TOKEN }}
        run: poetry publish --no-interaction --username __token__ --password $PYPI_TOKEN
